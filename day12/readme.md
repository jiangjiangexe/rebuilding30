# 談談單元測試

前面介紹了測試框架JUnit、斷言工具AssertJ、建立測試資料等，在分享超過10天、進入隔離章之前，終於要來談談單元測試了。並且整理一下，大多都是從91大的課程學到的筆記

## 為什麼是單元測試？

身為一位工程師，讓我先針對在開發經驗中最令我覺得煩躁的問題，自我做個排名並說明一下在沒有寫測試之前如何解決：

1. 測過哪些 // 做筆記反覆紀錄
2. 哪裡錯了 // 倚靠記憶力及經驗猜測
3. 改東壞西 // 付出很大的心力，小心不要改壞
4. 平行開發 // 所有人乾瞪眼，互相等來等去
5. 測試環境無法測試 // 譬如本機無法測試的，要丟到測試機測試

這看起來很糟、很沒有效率。該怎麼辦？所以讓我們看看如果用單元測試怎麼來解決。

1. 測過哪些 // 交付要含測試程式，是測試程式也是文件，只要有寫上去有執行通過的都是測過的。
2. 哪裡錯了 // 編寫良好的測試程式，只要帶入情境，就可以馬上找到問題，而如果是規格外的錯誤，則把他納入測試程式，保證下次不再出錯。
3. 改東壞西 // 改完程式馬上跑測試，可以立即知道本次的修改是否有造成其他問題
4. 平行開發 // 使用模擬物件來達到關注點分離
5. 測試環境無法測試 // 使用Mock模擬相依的物件

由於單元測試必須能自動且重複的執行，所以我們可以在編寫完程式的前後來執行，立即知道程式的正確性。接下來我們要先知道什麼是單元測試。

## 什麼是單元測試

1. 最小的測試單元：一般來說最小的單元即為一個方法，但也有可能會是幾個類別。
2. 不具備邏輯：這關乎於測試的本質，測試案例就是模擬外部如何使用待測程式(待測系統SUT)，很單純就是呼叫SUT的方法而已。
3. 外部相依為零：如果有相依，會不知道是SUT本身出錯，還是相依的物件出錯。
4. 測試案例之間的相依為零：同上，這會造成無法立即得知是誰出錯。
5. 一個測試案例只測一件事：怎麼知道一件事的範圍？這必須從需求面上來釐清，有時候我們只需要簡單的驗證回傳值，但也有可能是驗證前後的變化，是否符合預期。

## 單元測試必須具備的特性：FIRST

Fast：為了可以在開發過程中反覆進行測試，其執行速度就要快，而這得要讓待測系統的外部相依為零來達成。
Independent：獨立的，外部相依為零
Repeatable：當重複執行的時候，不管環境為何，結果相同
Self-Validating：測試程式必須要有驗證功能，並且能立即顯示錯誤或正確的資訊
Timely：即時性，意思是指在交付production code時，同時也必須交付完成的單元測試

## 如何編寫單元測試

我們在第三天就有提到，透過3A原則的步驟來編寫，如下：

1. Arrange：初始化待測物件、初始化相依物件、方法參數、預期結果(excepted)

2. Act：調用待測物件及其方法

3. Assert：驗證實際結果(actual)是否符合預期結果

## 一個測試案例只驗證一件事情

試圖將多個測試案例壓縮到一個，同時斷言多件事情，會造成：

1. 無法找出簡單明瞭的測試案例名稱。
2. 使得單一個測試案例沒有明確目標，變得難以閱讀及維護。
3. 當同時驗證多件事情，執行測試發生錯誤時，我們沒有辦法立即抓到發生的問題點。

## 單元測試的驗證方式

其實單元測試就是模擬外部如何使用待測程式(待測系統SUT)，大概會有以下三種情境：

1. 驗證回傳值：測試程式>呼叫待測系統的方法>測試程式得到其回傳值並驗證
2. 驗證狀態的改變：測試程式>呼叫待測系統的方法>待測系統狀態改變>測試程式取得狀態並驗證
3. 驗證外部互動：測試程式>呼叫待測系統的方法>(待測系統與模擬物件互動)>測試程式驗證互動

## Independent

相依可能會造成的問題：

- 測試可能因為相依而變慢，如網路、資料庫、檔案、外部物件等。
- 導致誤判測試的結果，是SUT本身出錯，還是相依的物件出錯。
- 等待相依的物件開發完成，才能測試待測物件。
- 無法測試，譬如開發與正式的環境不一樣。

隔離帶來的好處：
- 執行速度快
- 關注點分離，只需在意驗證的需求點
- 單一職責，出錯時，單純只有一個問題點
- 可測試性，因為相依可能會有變化，因此隔離避免了可能的無法測試
- 測試程式的強健性

最後提到了隔離，想要完成單元測試，則必須讓測試程式的外部相依為零，所以下一篇將會談到Mock模擬的做法。

寫單元測試的過程中會有些迷惘，不知道這樣寫對不對

Top-Down由上而下地編寫程式

與客戶溝通結束要做的東西之後，可能會有一份需求功能列表，那該如何實作呢？

1. Bottom-Up由下而上，以編寫網站的分層架構來看，我們會先從Data Model開始建立，編寫Dao，Service，Controller，最後是使用介面。

2. Top-Down由上而下，則是從實作介面，Controller，Service，Dao，Data Model的順序執行。

這看起來只是一般實作的編寫順序，但

1. 如果由下而上實作，可能會因為實作的結果離需求比較遠，造成寫出來的測試案例無法貼近需求，還得耗費心力修改

2. 如果由上而下實作，可以發現上層的需求直接定義了下層的案例，這代表著我們的需求是實際業務需求所需要的，那麼編寫的測試案例也會自然的符合需求。